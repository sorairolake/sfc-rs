// SPDX-FileCopyrightText: 2025 Shun Sakai
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! An implementation of the sfc64 random number generator.

use rand_core::{impls, le, RngCore, SeedableRng};

/// A sfc64 random number generator.
///
/// The sfc64 algorithm is not suitable for cryptographic uses but is very fast.
///
/// # Examples
///
/// ```
/// # use rand_sfc::{
/// #     rand_core::{RngCore, SeedableRng},
/// #     Sfc64,
/// # };
/// #
/// let mut rng = Sfc64::from_seed([0; 24]);
/// assert_eq!(rng.next_u64(), 0x3acf_a029_e3cc_6041);
/// ```
#[derive(Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]
pub struct Sfc64 {
    a: u64,
    b: u64,
    c: u64,
    counter: u64,
}

impl RngCore for Sfc64 {
    #[allow(clippy::cast_possible_truncation)]
    #[inline]
    fn next_u32(&mut self) -> u32 {
        self.next_u64() as u32
    }

    #[inline]
    fn next_u64(&mut self) -> u64 {
        const ROTATION: u32 = 24;
        const RIGHT_SHIFT: u32 = 11;
        const LEFT_SHIFT: u32 = 3;

        let tmp = self.a.wrapping_add(self.b).wrapping_add(self.counter);
        self.counter += 1;
        self.a = self.b ^ (self.b >> RIGHT_SHIFT);
        self.b = self.c.wrapping_add(self.c << LEFT_SHIFT);
        self.c = self.c.rotate_left(ROTATION).wrapping_add(tmp);
        tmp
    }

    #[inline]
    fn fill_bytes(&mut self, dst: &mut [u8]) {
        impls::fill_bytes_via_next(self, dst);
    }
}

impl SeedableRng for Sfc64 {
    type Seed = [u8; 24];

    #[inline]
    fn from_seed(seed: Self::Seed) -> Self {
        let mut s = [u64::default(); 3];
        le::read_u64_into(&seed, &mut s);
        let mut state = Self {
            a: s[0],
            b: s[1],
            c: s[2],
            counter: 1,
        };
        for _ in 0..12 {
            state.next_u64();
        }
        state
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // This test vector was generated by the `RNG_output` command of PractRand
    // version pre0.95.
    //
    // To generate a hex dump:
    //
    // ```sh
    // ./RNG_output sfc64 128 0 | xxd -i
    // ```
    const EXPECTED: [u64; 16] = [
        0x3acf_a029_e3cc_6041,
        0xf5b6_515b_f2ee_419c,
        0x1259_6358_94a2_9b61,
        0x0b6a_e753_95f8_ebd6,
        0x2256_2228_5ce3_02e2,
        0x520d_2861_1395_cb21,
        0xdb90_9c81_8901_599d,
        0x8ffd_1953_6521_6f57,
        0xe8c4_ad5e_258a_c04a,
        0x8f8e_f2c8_9fdb_63ca,
        0xf986_5b01_d98d_8e2f,
        0x4655_5871_a65d_08ba,
        0x6686_8677_c629_8fcd,
        0x2ce1_5a7e_6329_f57d,
        0x0b2f_1833_ca91_ca79,
        0x4b08_90ac_9bf4_53ca,
    ];

    #[test]
    fn next_u32() {
        let mut rng = Sfc64::from_seed([u8::default(); 24]);
        for e in EXPECTED {
            assert_eq!(rng.next_u32(), e as u32);
        }
    }

    #[test]
    fn next_u64() {
        let mut rng = Sfc64::from_seed([u8::default(); 24]);
        for e in EXPECTED {
            assert_eq!(rng.next_u64(), e);
        }
    }

    #[test]
    fn fill_bytes() {
        let mut rng = Sfc64::from_seed([u8::default(); 24]);
        let mut dst = [u8::default(); 8];
        for e in EXPECTED {
            rng.fill_bytes(&mut dst);
            assert_eq!(dst, e.to_le_bytes());
        }
    }

    #[cfg(feature = "serde")]
    #[test]
    fn serde() {
        let mut rng = Sfc64::from_seed([u8::default(); 24]);

        let json = serde_json::to_string(&rng).unwrap();
        assert_eq!(
            json,
            r#"{"a":3105171942637071872,"b":1132609933517779508,"c":3891116077132813732,"counter":13}"#
        );

        let mut deserialized_rng = serde_json::from_str::<Sfc64>(&json).unwrap();
        assert_eq!(deserialized_rng, rng);
        assert_eq!(deserialized_rng.next_u64(), rng.next_u64());
    }
}
